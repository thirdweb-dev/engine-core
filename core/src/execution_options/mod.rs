use schemars::JsonSchema;
use serde::de::{Error, IntoDeserializer};
use serde::{Deserialize, Deserializer, Serialize};
use serde_with::{DisplayFromStr, PickFirst, serde_as};
use std::collections::HashMap;

use crate::transaction::InnerTransaction;
pub mod aa;
pub mod auto;
pub mod eip7702;
pub mod eoa;

// Base execution options for all transactions
// All specific execution options share this
#[serde_as]
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct BaseExecutionOptions {
    #[serde_as(as = "PickFirst<(_, DisplayFromStr)>")]
    pub chain_id: u64,
    #[serde(default = "default_idempotency_key")]
    pub idempotency_key: String,
}

fn default_idempotency_key() -> String {
    uuid::Uuid::new_v4().to_string()
}

/// All supported specific execution options are contained here
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, utoipa::ToSchema)]
#[serde(tag = "type")]
#[schema(title = "Execution Option Variants")]
pub enum SpecificExecutionOptions {
    #[serde(rename = "auto")]
    #[schema(title = "Auto Determine Execution", default)]
    Auto(auto::AutoExecutionOptions),

    #[schema(title = "ERC-4337 Execution Options")]
    ERC4337(aa::Erc4337ExecutionOptions),

    #[serde(rename = "EOA")]
    #[schema(title = "EOA Execution Options")]
    EOA(eoa::EoaExecutionOptions),

    #[schema(title = "EIP-7702 Execution Options")]
    EIP7702(eip7702::Eip7702ExecutionOptions),
}

fn deserialize_with_default_auto<'de, D>(
    deserializer: D,
) -> Result<SpecificExecutionOptions, D::Error>
where
    D: Deserializer<'de>,
{
    let mut map: HashMap<String, serde_json::Value> = HashMap::deserialize(deserializer)?;

    // If no "type" field exists, add it with "Auto"
    if !map.contains_key("type") {
        map.insert(
            "type".to_string(),
            serde_json::Value::String("auto".to_string()),
        );
    }

    // Convert HashMap back to deserializer and deserialize normally
    SpecificExecutionOptions::deserialize(map.into_deserializer()).map_err(D::Error::custom)
}

/// This is the exposed API for execution options
/// Base and specific execution options are both flattened together
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct ExecutionOptions {
    #[serde(flatten)]
    pub base: BaseExecutionOptions,
    #[serde(flatten, deserialize_with = "deserialize_with_default_auto")]
    pub specific: SpecificExecutionOptions,
}

const MAX_USER_METADATA_SIZE: usize = 4096; // 4KB limit

fn validate_user_metadata_size(metadata: &Option<String>) -> Result<(), String> {
    if let Some(meta) = metadata {
        if meta.len() > MAX_USER_METADATA_SIZE {
            return Err(format!(
                "User metadata exceeds maximum size of {} bytes (provided: {} bytes)",
                MAX_USER_METADATA_SIZE,
                meta.len()
            ));
        }
    }
    Ok(())
}

fn deserialize_and_validate_user_metadata<'de, D>(
    deserializer: D,
) -> Result<Option<String>, D::Error>
where
    D: Deserializer<'de>,
{
    let metadata: Option<String> = Option::deserialize(deserializer)?;
    validate_user_metadata_size(&metadata).map_err(D::Error::custom)?;
    Ok(metadata)
}

#[derive(Serialize, Deserialize, Debug, Clone, JsonSchema, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct WebhookOptions {
    pub url: String,
    pub secret: Option<String>,
    /// Custom metadata provided by the user to be included in webhook notifications.
    /// Limited to 4KB (4096 bytes) to prevent abuse.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    #[serde(deserialize_with = "deserialize_and_validate_user_metadata")]
    pub user_metadata: Option<String>,
}

/// Incoming transaction request, parsed into InnerTransaction
/// Exposed API will have varying `params` but will all parse into InnerTransaction before execution
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct SendTransactionRequest {
    pub execution_options: ExecutionOptions,
    pub params: Vec<InnerTransaction>,
    #[serde(default)]
    pub webhook_options: Vec<WebhookOptions>,
}

/// # QueuedTransaction
/// Response for any request that queues one or more transactions
#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct QueuedTransaction {
    /// The idempotency key this transaction was queued with
    /// Either autogenerated UUID or provided by the user
    /// Multiple queued transactions can have the same idempotency key
    /// A "blockchain transaction" is uniquely identified by the idempotency key + batchIndex
    pub id: String,

    /// When multiple transactions are sent together via an execution mode that doesn't support atomic batching,
    /// each transaction will have a unique batchIndex but the same id (idempotency key)
    /// This maintains the relationship between different atomically sent blockchain transactions that were queued together
    pub batch_index: u64,

    /// The fully resolved execution options for this transaction, derived from the resolution of user specific execution options
    /// Difference in naming is to prevent confusion when response executionParams contain different values than the request executionOptions
    pub execution_params: ExecutionOptions,

    /// This is the actual encoded inner transaction data that will be sent to the blockchain.
    /// For non-atomic transactions, this will be a single transaction
    /// For atomic transactions, this will be a list of transactions, because they were atomically sent together
    pub transaction_params: Vec<InnerTransaction>,
}

#[derive(Debug, Clone, Serialize, Deserialize, utoipa::ToSchema)]
pub struct QueuedTransactionsResponse {
    pub transactions: Vec<QueuedTransaction>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutorType {
    #[serde(rename = "ERC4337")]
    Erc4337,
    #[serde(rename = "EOA")]
    Eoa,
    #[serde(rename = "EIP7702")]
    Eip7702,
}

impl ExecutionOptions {
    pub fn executor_type(&self) -> ExecutorType {
        match &self.specific {
            SpecificExecutionOptions::ERC4337(_) => ExecutorType::Erc4337,
            SpecificExecutionOptions::Auto(_) => ExecutorType::Erc4337,
            SpecificExecutionOptions::EOA(_) => ExecutorType::Eoa,
            SpecificExecutionOptions::EIP7702(_) => ExecutorType::Eip7702,
        }
    }

    pub fn chain_id(&self) -> u64 {
        self.base.chain_id
    }

    pub fn transaction_id(&self) -> &str {
        &self.base.idempotency_key
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_webhook_options_user_metadata_validation() {
        // Test valid metadata
        let valid_json = r#"{
            "url": "https://example.com/webhook",
            "secret": "test_secret",
            "userMetadata": "test metadata"
        }"#;

        let webhook_options: Result<WebhookOptions, _> = serde_json::from_str(valid_json);
        assert!(webhook_options.is_ok());
        assert_eq!(
            webhook_options.unwrap().user_metadata,
            Some("test metadata".to_string())
        );

        // Test metadata that's too large (over 4KB)
        let large_metadata = "x".repeat(5000); // 5KB string
        let invalid_json = format!(
            r#"{{
            "url": "https://example.com/webhook", 
            "secret": "test_secret",
            "userMetadata": "{}"
        }}"#,
            large_metadata
        );

        let webhook_options: Result<WebhookOptions, _> = serde_json::from_str(&invalid_json);
        assert!(webhook_options.is_err());

        // Test missing metadata (should default to None)
        let minimal_json = r#"{
            "url": "https://example.com/webhook"
        }"#;

        let webhook_options: Result<WebhookOptions, _> = serde_json::from_str(minimal_json);
        assert!(webhook_options.is_ok());
        assert_eq!(webhook_options.unwrap().user_metadata, None);
    }
}
