use alloy::consensus::{Receipt, ReceiptWithBloom};
use alloy::eips::eip7702::SignedAuthorization;
use alloy::primitives::{Address, Bytes, U256};
use alloy::rpc::client::RpcClient;
use alloy::rpc::types::{Log, TransactionReceipt};
use alloy::transports::{IntoBoxTransport, TransportResult};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;

use crate::userop::VersionedUserOp;

// Gas buffer added for managed account factories (matches TypeScript)
pub const MANAGED_ACCOUNT_GAS_BUFFER: U256 = U256::from_limbs([21_000, 0, 0, 0]);

/// A JSON-RPC client for interacting with an ERC-4337 bundler and paymaster
#[derive(Debug, Clone)]
pub struct BundlerClient {
    pub inner: RpcClient,
}

#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UseropGasEstimation {
    pub call_gas_limit: U256,
    pub verification_gas_limit: U256,
    pub pre_verification_gas: U256,
    #[serde(alias = "paymasterVerificationGas")]
    pub paymaster_verification_gas_limit: U256,
    #[serde(alias = "paymasterPostOpGas")]
    pub paymaster_post_op_gas_limit: Option<U256>,
}

/// Represents the receipt of a user operation.
// Not using UserOperationReceipt from alloy because it uses `TransactionReceipt<ReceiptEnvelope<Log>>`, which depends on a tagged enum by `type` field
// RPC response for receipt does not return `type` field, so we cannot use `TransactionReceipt<ReceiptEnvelope<Log>>` directly
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct UserOperationReceipt {
    /// The hash of the user operation.
    pub user_op_hash: Bytes,
    /// The entry point address for the user operation.
    pub entry_point: Address,
    /// The address of the sender of the user operation.
    pub sender: Address,
    /// The nonce of the user operation.
    pub nonce: U256,
    /// The address of the paymaster, if any.
    pub paymaster: Address,
    /// The actual gas cost incurred by the user operation.
    pub actual_gas_cost: U256,
    /// The actual gas used by the user operation.
    pub actual_gas_used: U256,
    /// Indicates whether the user operation was successful.
    pub success: bool,
    /// The reason for failure, if any.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<Bytes>,
    /// The logs generated by the user operation.
    pub logs: Vec<Log>,
    /// The transaction receipt of the user operation.
    pub receipt: TransactionReceipt<ReceiptWithBloom<Receipt<Log>>>,
}

/// Response from tw_execute bundler method
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TwExecuteResponse {
    /// The queue ID returned by the bundler
    pub queue_id: String,
}

/// Response from tw_getTransactionHash bundler method
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase", tag = "status")]
pub enum TwGetTransactionHashResponse {
    Pending,
    #[serde(rename_all = "camelCase")]
    Success {
        transaction_hash: String,
    },
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum TwGetTransactionHashStatus {
    Pending,
    Success,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct TwGetDelegationContractResponse {
    pub delegation_contract: Address,
}

impl BundlerClient {
    /// Create a new bundler client with the given transport
    pub fn new(transport: impl IntoBoxTransport) -> Self {
        let client = RpcClient::builder().transport(transport, false);

        Self { inner: client }
    }

    /// Get a user operation receipt by hash
    pub async fn get_user_op_receipt(
        &self,
        user_op_hash: Bytes,
    ) -> TransportResult<Option<UserOperationReceipt>> {
        self.inner
            .request("eth_getUserOperationReceipt", [user_op_hash])
            .await
    }

    /// Estimate the gas for a user operation
    pub async fn estimate_user_op_gas(
        &self,
        user_op: &VersionedUserOp,
        entrypoint: Address,
        state_overrides: Option<HashMap<String, HashMap<String, String>>>,
    ) -> TransportResult<UseropGasEstimation> {
        let state_overrides = state_overrides.unwrap_or_default();

        // Convert the result and apply gas buffer to match TypeScript implementation
        let result: UseropGasEstimation = self
            .inner
            .request(
                "eth_estimateUserOperationGas",
                (user_op, entrypoint, state_overrides),
            )
            .await?;

        Ok(UseropGasEstimation {
            call_gas_limit: result.call_gas_limit + MANAGED_ACCOUNT_GAS_BUFFER,
            ..result
        })
    }

    pub async fn send_user_op(
        &self,
        user_op: &VersionedUserOp,
        entrypoint: Address,
    ) -> TransportResult<Bytes> {
        let result: Bytes = self
            .inner
            .request("eth_sendUserOperation", (user_op, entrypoint))
            .await?;

        Ok(result)
    }

    /// Execute an EIP-7702 transaction via the bundler
    pub async fn tw_execute(
        &self,
        eoa_address: Address,
        wrapped_calls: &Value,
        signature: &str,
        authorization: Option<&SignedAuthorization>,
    ) -> TransportResult<String> {
        let params = serde_json::json!([eoa_address, wrapped_calls, signature, authorization]);

        let response: TwExecuteResponse = self.inner.request("tw_execute", params).await?;

        Ok(response.queue_id)
    }

    /// Get transaction hash from bundler using transaction ID  
    pub async fn tw_get_transaction_hash(
        &self,
        transaction_id: &str,
    ) -> TransportResult<TwGetTransactionHashResponse> {
        let params = serde_json::json!([transaction_id]);

        let response: TwGetTransactionHashResponse =
            self.inner.request("tw_getTransactionHash", params).await?;

        Ok(response)
    }

    pub async fn tw_get_delegation_contract(&self) -> TransportResult<TwGetDelegationContractResponse> {
        let response: TwGetDelegationContractResponse = self.inner.request("tw_getDelegationContract", ()).await?;
        Ok(response)
    }
}
